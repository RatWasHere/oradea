<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Wacca Style Tunnel</title>
  <style>
    :root {
      --tunnel-size: 100px;
      --ring-inner: 30%;
      --ring-outer: 70%;
      --arc-start: 10deg;
      --arc-angle: 60deg; /* NEW: arc size */
      --arc-end: calc(var(--arc-start) + var(--arc-angle));
      --ring-color: cyan;
    }

    .viewport {
      perspective: 800px;
      /* Controls the strength of the 3D effect */
      overflow: hidden;
      width: 100vw;   
      height: 100vh;
      background: black;
      position: relative;
    }

    .tunnel-item {
      width: var(--tunnel-size);
      height: var(--tunnel-size);
      background:
        radial-gradient(circle, transparent var(--ring-inner), var(--ring-color) calc(var(--ring-inner) + 1%), var(--ring-color) var(--ring-outer), transparent calc(var(--ring-outer) + 1%));
      position: absolute;
      top: 50%;
      left: 50%;
      border-radius: 50%;
      transform-style: preserve-3d;
      animation: tunnelMove 3s linear infinite;
      -webkit-mask-image: conic-gradient(transparent 0deg var(--arc-start), white var(--arc-start) var(--arc-end), transparent var(--arc-end) 360deg);
      mask-image: conic-gradient(transparent 0deg var(--arc-start), white var(--arc-start) var(--arc-end), transparent var(--arc-end) 360deg);
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
    }

    @keyframes war {
      0% {
        rotate: 0deg;
      }
      100% {
        rotate: -360deg;
      }
    }

    @keyframes tunnelMove {
      0% {
        transform: translate(-50%, -50%) translateZ(-1000px) scale(0.8);
        opacity: 0;
      }

      50% {
        opacity: 1;
      }

      100% {
        transform: translate(-50%, -50%) translateZ(0px) scale(1.5);
        opacity: 0;
      }
    }
  </style>
</head>
<body>

  <a href="../Picker/LevelPicker.html">back</a>
  <a href="./lightmap.html">lightmap</a>
</body>
<script>
  let parser = require('osu-mania-parser');
  let beatmap = parser.parseFileSync('./Misc/beatmap.osu');
  let sheet = [];
  function swap(json){
  var ret = {};
  for(var key in json){
    ret[json[key]] = key;
  }
  return ret;
}

  let keyPositions = swap(beatmap.keyPositions);

  beatmap.hitObjects.forEach((hitObject, index) => {
    if (hitObject.type == "note") {
      let additionalOptions = {};
      if (hitObject.hitSound.includes("clap") && hitObject.hitSound.includes("whistle")) {
        additionalOptions.golden = true
      } else if (hitObject.hitSound.includes("clap")) {
        additionalOptions.flickDirection = 1;
        additionalOptions.flick = true;
      } else if (hitObject.hitSound.includes("whistle")) {
        additionalOptions.flickDirection = 2;
        additionalOptions.flick = true;
      } else if (hitObject.hitSound.includes("finish")) {
        additionalOptions.hold = true;
      }
      sheet.push({
        time: hitObject.time,
        angle: keyPositions[hitObject.x],
        ...additionalOptions
      });
    } else if (hitObject.type == "hold") {
      let additionalOptions = {};
      if (hitObject.hitSound.includes("finish") && hitObject.hitSound.includes("whistle")) {
        additionalOptions.holdableEnd = true;
        additionalOptions.flickableAway = true;
        if (hitObject.hitSound.includes("clap")) {
          additionalOptions.holdableStart = true;
        }
      } else if (hitObject.hitSound.includes("clap")) {
        additionalOptions.holdableStart = true;
      } else if (hitObject.hitSound.includes("whistle")) {
        additionalOptions.golden = true;
      } else if (hitObject.hitSound.includes("finish")) {
        additionalOptions.holdableStart = true;
        additionalOptions.holdableEnd = true;
      }
      sheet.push({
        time: hitObject.time,
        angle: keyPositions[hitObject.x],
        slider: true,
        sliderEnd: hitObject.endTime,
      });
    }
  });

  // ...existing code...
  // after building `sheet` from beatmap.hitObjects, add this block:
  (function combineSimultaneousSliders() {
    // group slider entries by start+end time
    let sliderGroups = {};
    sheet.forEach((entry, idx) => {
      if (entry.slider) {
        const key = `${entry.time}_${entry.sliderEnd}`;
        sliderGroups[key] = sliderGroups[key] || [];
        sliderGroups[key].push({ entry, idx });
      }
    });

    // find groups of size 3 or 4
    const combineKeys = Object.keys(sliderGroups).filter(k => {
      const c = sliderGroups[k].length;
      return c === 3 || c === 4;
    });

    if (combineKeys.length === 0) return;

    const skip = new Set();
    const combinedEntries = [];

    combineKeys.forEach(key => {
      const group = sliderGroups[key];
      // mark original entries to be removed
      group.forEach(g => skip.add(g.idx));

      // compute average angle for the new long flick
      const angles = group.map(g => g.entry.angle);
      const avgAngle = angles.reduce((a, b) => a + b, 0) / angles.length;

      const startTime = group[0].entry.time;
      const endTime = group[0].entry.sliderEnd;
      const distance = group.length === 3 ? 2 : 3;

      combinedEntries.push({
        time: startTime,
        flickEnd: endTime,
        angle: avgAngle,
        largeFlick: true,
        flickDirection: 1,
        direction: distance,
      });
    });

    // build a new sheet without the original combined sliders, then add combined entries
    const newSheet = sheet.filter((_, idx) => !skip.has(idx));
    newSheet.push(...combinedEntries);

    // keep sheet sorted by time (and angle as tie-breaker)
    newSheet.sort((a, b) => (a.time - b.time) || ((a.angle || 0) - (b.angle || 0)));

    sheet = newSheet;
  })();
  require('fs').writeFileSync('./Misc/map.json', JSON.stringify(sheet, null, 2));

</script>
</html>