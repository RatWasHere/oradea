<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <style>
    :root {
      --tunnel-size: 100px;
      --ring-inner: 30%;
      --ring-outer: 70%;
      --arc-start: 10deg;
      --arc-angle: 60deg;
      /* NEW: arc size */
      --arc-end: calc(var(--arc-start) + var(--arc-angle));
      --ring-color: cyan;
    }

    .viewport {
      perspective: 800px;
      /* Controls the strength of the 3D effect */
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      background: black;
      position: relative;
    }

    .tunnel-item {
      width: var(--tunnel-size);
      height: var(--tunnel-size);
      background:
        radial-gradient(circle, transparent var(--ring-inner), var(--ring-color) calc(var(--ring-inner) + 1%), var(--ring-color) var(--ring-outer), transparent calc(var(--ring-outer) + 1%));
      position: absolute;
      top: 50%;
      left: 50%;
      border-radius: 50%;
      transform-style: preserve-3d;
      animation: tunnelMove 3s linear infinite;
      -webkit-mask-image: conic-gradient(transparent 0deg var(--arc-start), white var(--arc-start) var(--arc-end), transparent var(--arc-end) 360deg);
      mask-image: conic-gradient(transparent 0deg var(--arc-start), white var(--arc-start) var(--arc-end), transparent var(--arc-end) 360deg);
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
    }

    @keyframes war {
      0% {
        rotate: 0deg;
      }

      100% {
        rotate: -360deg;
      }
    }

    @keyframes tunnelMove {
      0% {
        transform: translate(-50%, -50%) translateZ(-1000px) scale(0.8);
        opacity: 0;
      }

      50% {
        opacity: 1;
      }

      100% {
        transform: translate(-50%, -50%) translateZ(0px) scale(1.5);
        opacity: 0;
      }
    }
  </style>
</head>

<body>

  <a href="../Picker/LevelPicker.html">back</a>
  <a href="./lightmap.html">lightmap</a>
  <a href="./oldwcs.html">old</a>
</body>
<script>
  let parser = require('osu-mania-parser');
  let beatmap = parser.parseFileSync('./Misc/beatmap.osu');
  let sheet = [];
  function swap(json) {
    var ret = {};
    for (var key in json) {
      ret[json[key]] = key;
    }
    return ret;
  }

  let angleMap = {
    "0": 5,
    "1": 0,
    "2": 1,
    "3": 2,
    "4": 3,
    "5": 4
  }

  let keyPositions = swap(beatmap.keyPositions);
  beatmap.hitObjects.forEach((hitObject, index) => {
    if (hitObject.type == "note") {
      let additionalOptions = {};
      if (hitObject.hitSound.includes("clap") && hitObject.hitSound.includes("whistle")) {
        additionalOptions.golden = true
      } else if (hitObject.hitSound.includes("clap")) {
        additionalOptions.flickDirection = 1;
        additionalOptions.flick = true;
      } else if (hitObject.hitSound.includes("whistle")) {
        additionalOptions.flickDirection = 2;
        additionalOptions.flick = true;
      } else if (hitObject.hitSound.includes("finish")) {
        additionalOptions.holdable = true;
      }
      sheet.push({
        time: hitObject.time,
        angle: angleMap[keyPositions[hitObject.x]],
        ...additionalOptions
      });
    } else if (hitObject.type == "hold") {
      if (!hitObject.hitSound.includes('normal')) {
        let supposedObject = {
          time: hitObject.time,
          swipe: true,
          swipeEnd: hitObject.endTime,
          angle: angleMap[keyPositions[hitObject.x]]
        };

        if (hitObject.hitSound.includes('finish')) {
          if (hitObject.hitSound.includes("whistle") && hitObject.hitSound.includes("clap")) {
          } else if (hitObject.hitSound.includes("whistle")) {
            supposedObject.quarterSwipe = true;
            supposedObject.direction = -1;
          } else if (hitObject.hitSound.includes("clap")) {
            supposedObject.quarterSwipe = true;
            supposedObject.direction = 1;
          } else {
            supposedObject.halfSwipe = true;
            supposedObject.direction = -1;
          }
        } else if (hitObject.hitSound.includes('whistle') && hitObject.hitSound.includes('clap')) {
            supposedObject.halfSwipe = true;
            supposedObject.direction = 1;
        } else if (hitObject.hitSound.includes('whistle')) {
          supposedObject.shortSwipe = true;
          supposedObject.direction = 1;
        } else if (hitObject.hitSound.includes('clap')) {
          supposedObject.shortSwipe = true;
          supposedObject.direction = -1;
        }
        sheet.push(supposedObject)
      } else {
        let additionalOptions = {};
        if (hitObject.hitSound.includes("finish") && hitObject.hitSound.includes("whistle")) {
          additionalOptions.holdableEnd = true;
          additionalOptions.flickableAway = true;
          if (hitObject.hitSound.includes("clap")) {
            additionalOptions.holdableStart = true;
          }
        } else if (hitObject.hitSound.includes("clap")) {
          additionalOptions.holdableStart = true;
        } else if (hitObject.hitSound.includes("whistle")) {
          additionalOptions.golden = true;
        } else if (hitObject.hitSound.includes("finish")) {
          additionalOptions.holdableStart = true;
          additionalOptions.holdableEnd = true;
        }
        sheet.push({
          time: hitObject.time,
          angle: angleMap[keyPositions[hitObject.x]],
          slider: true,
          sliderEnd: hitObject.endTime,
        });
      }
    }
  });

  let leftAlignedAngles = ["2", "3", "4"]
  let dupeCheck = {};
  sheet.forEach((item) => {
    let itemPosition = leftAlignedAngles.includes(item.angle) ? 'L' : 'R'
    if (!dupeCheck[`${item.time}${itemPosition}`]) {
      dupeCheck[`${item.time}${itemPosition}`] = item;
    } else {
      console.log('Dupe ', item, dupeCheck[`${item.time}${itemPosition}`])
    }
  })
  require('fs').writeFileSync('./Misc/map.json', JSON.stringify(sheet, null, 2));
  console.log(sheet)
</script>

</html>